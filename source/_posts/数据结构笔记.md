---
title: 数据结构笔记
date: 2024-11-03 15:04:29
tags:
- 课内
---
 <!-- more -->

## 二叉树

### 基本概念

结点度 = 子节点的个数

结点的层次(深度) = 从根结点到该结点的路径长

结点的高度(叶结点:1) = 从该结点到叶子结点的最大值

有序树:子树不能交换

满二叉树:没有度=1的结点

完全二叉树(d>3):(1)从1到d-2层都是度为2的中间结点; (2)d-1层是度为1的结点, 且从左到右顺序排列; (3)d层是度为0的叶结点 **大根堆**

完美二叉树:完全二叉树是满二叉树, 且所有d-1层结点都是度为2的结点

扩充二叉树:二叉树结点的空子树位置添加空树叶

### 基本性质

1.设非空二叉树中度为$i\in[0,2]$的结点个数为$n_i$，则$n_0+n_1+n_2=n$，且$n_0=1+n_2$(用边数证明)

2.非空*满*二叉树**叶结点数**等于**中间节点数**+1

3.设完全二叉树有n个结点,按层次从左向右编号,则树中任意结点(1<=k<=n)满足:

- (1)若2k<=n,则k的左子节点为2k,否则没有左子节点;
- (2)若2k+1<=n,则k的右子节点为2k+1,否则没有右子结点;
- (3)若k>1,则k的父节点是k/2

4.有n个结点的完全二叉树深度为$d=\log_2(n+1)$

### 存储实现

#### 1.顺序存储

结点分层从左向右连续编号,用顺序表储存

#### 2.链式存储

二叉链表: left right data

三叉链表: left right data parent

### 遍历

#### 深度优先遍历

按序独立处理二叉树各分支单元:**根r,左子树L,右子树R**

- 递归
- 深度原则
- 从左向右

#### 广度优先遍历

从上到下,从左向右依次访问树中所有结点,也称*层序遍历*

#### 递归方法(从小到大的子树)

1.前序遍历:r->L->R

2.中序遍历:L->r->R

3.后序遍历:L->R->r

**根节点:前序遍历前,后序遍历后,中序遍历中(左右子树遍历结果之间)**.

#### 非递归方法(从大到小)

### 序列化与反序列化

'#'表示空节点

#### 1.序列化:树---遍历规则--->字符串



#### 2.反序列化:根据线性序列**重构**原始二叉树

### 带权二叉树

带权路径长度:$WPL=\sum_{i=1}^n w_i\cdot d_i$

#### 最优二叉树

给定叶结点权重,构建的带权二叉树中,带权路径长度最小的二叉树.(**哈夫曼树**)

- 哈夫曼树是满二叉树
- 哈夫曼树中,如果两个叶结点权重不同,则权重值小的叶结点在树中层数大于等于权重值大的叶结点.
- 给定叶结点权重,存在哈夫曼树,权重最小和次小的在树的最下层层并互为兄弟结点.

#### 哈夫曼算法

自下而上,不断取出**结点权重最小和次小的二叉树**,作为新节点的左右子树,设置节点权重为两棵子树的权重之和,直到剩下一棵树为止.

##### 应用:哈夫曼编码

二叉树表示前缀码
: 给定字符串,求最优前缀码,使得编码出的二进制字符串长度最短.

##### 应用:多路合并

### 父亲表示法

**每个节点保存父节点的位置信息**

#### 应用:最近公共祖先

## 拓展

### 前缀树

字典树,用于存储字符串集合,每个节点保存字符串的前缀,每个节点指向字符串集合.
所有字符串的共同前缀合并再一条路径上表示
**应用:文本词频统计**

- 基本操作:插入,查找 O(n)

### 后缀自动机

书上保留所有字串信息
**最长重复子串,最长公共子串**

### 决策树

机器学习...

