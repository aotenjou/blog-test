---
title: 补题
date: 2024-10-20 16:24:25
tags:
- 课内
---
<!--more-->

## 2024.10.20

2道递归模板 + 1道模拟栈

**tips:UB(Undifined Behavior) 未定义行为**
指程序的行为在语言标准中没有明确定义，因此可以表现为任何结果。

这意味着当程序出现未定义行为时，它可能会产生不可预测的结果，包括程序崩溃、数据损坏、安全漏洞，甚至可能看起来正常运行。

未定义行为是C语言中一个重要的概念，因为它涉及到程序的正确性和安全性。

*1.luoguP1605*.

![1](https://pic.imgdb.cn/item/6714cbd9d29ded1a8c9f3da5.png)

思路:dfs模板.

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int q[101][101];
    int sum=0;
    int i,j,n,m,t,sx,sy,x,y,ex,ey;
    void dfs(int a,int b)
    {
        if (a==ex&&b==ey)
        {
            sum++;
            return;
        }
        else
        {
            q[a][b]=0;
            if(q[a-1][b]) {dfs(a-1,b);q[a-1][b]=1;}
            if(q[a][b-1]) {dfs(a,b-1);q[a][b-1]=1;}
            if(q[a][b+1]) {dfs(a,b+1);q[a][b+1]=1;}
            if(q[a+1][b]) {dfs(a+1,b);q[a+1][b]=1;}
        }
    }
    int main()
    {
        memset(q,0,sizeof(q));
        cin>>n>>m>>t;
        cin>>sx>>sy>>ex>>ey;
        for(i=1;i<=n;i++)
            for(j=1;j<=m;j++)
                q[i][j]=1;
        for(i=1;i<=t;i++)
        {
            cin>>x>>y;
            q[x][y]=0;
        }
        dfs(sx,sy);
        cout<<sum<<endl;
        return 0;
    }
```

*2.luoguP1255*.

![2](https://pic.imgdb.cn/item/6714cce7d29ded1a8ca1cb20.png)

思路:高精度+斐波那契.开3个数组,两个状态一个结果.

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a[5000],b[5000],c[5000];
    int main()
    {
        int n;
        int x=1;
        cin>>n;
        if(n<3)
        {
            cout<<n;
            return 0;
        }
        a[1]=1;b[1]=2;
        for(int i=3;i<=n;i++)
        {
            for(int j=1;j<=x;j++)
                c[j]=a[j]+b[j];
            for(int j=1;j<=x;j++)
            {
                if(c[j]>9)
                {
                    c[j+1]=c[j+1]+c[j]/10;
                    c[j]%=10;
                    if(j+1>x)
                        x++;
                }
            }
            for(int j=1;j<=x;j++)
                a[j]=b[j];
            for(int j=1;j<=x;j++)
                b[j]=c[j];
        }
        for(int i=x;i>0;i--)
            cout<<b[i];
        return 0;
    }
```

*3.模拟栈*.

![3](https://pic.imgdb.cn/item/6715144fd29ded1a8c210fba.png)

思路:对于所有方法可以分成2类:

- 第一种: 元素入栈之后立刻出栈，那么出栈序列的顺序还是1，2，…，n的顺序；
- 第二种: 一直入栈，然后开始出栈，那么出栈序列的顺序就是k，k-1，……，1；

```cpp
    #include <iostream>
    #include <stack>
    #include <string>

    using namespace std;

    int main() {
    string in_seq, out_seq;
    getline(cin, in_seq);
    getline(cin, out_seq);

    stack<char> s;
    string op_seq = "";
    int in_idx = 0, out_idx = 0;

    while (out_idx < out_seq.length()) {
        if (!s.empty() && s.top() == out_seq[out_idx]) {
        s.pop();
        op_seq += "O";
        out_idx++;
        } else {
        while (in_idx < in_seq.length() && in_seq[in_idx] != out_seq[out_idx]) {
            s.push(in_seq[in_idx]);
            op_seq += "P";
            in_idx++;
        }
        if (in_idx == in_seq.length()) {
            cout << "wrong" << endl;
            string remaining = "";
            while (!s.empty()) {
            remaining = s.top() + remaining;
            s.pop();
            }
            cout << remaining << endl;
            return 0;
        } else {
            s.push(in_seq[in_idx]);
            op_seq += "P";
            in_idx++;
            s.pop();
            op_seq += "O";
            out_idx++;
        }
        }
    }
    cout << "right" << endl;
    cout << op_seq << endl;

    return 0;
    }
```

